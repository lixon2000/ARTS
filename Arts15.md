Arts15
===

# Algorithm
## 88. 合并两个有序数组  <https://leetcode-cn.com/problems/merge-sorted-array/>
### 描述：给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。
### 思路：双指针从后向前填充。
### java实现：
	class Solution {
      public void merge(int[] nums1, int m, int[] nums2, int n) {


        // 指向最后
        int p1 = m-1;
        int p2 = n-1;

        int p = m+n-1;

        while(p1 >= 0 && p2 >= 0){
          int max = 0;		// 大的数
          if(nums1[p1] > nums2[p2]){
            max = nums1[p1];
            p1--;
          } else{
            max = nums2[p2];
            p2--;
          }
          nums1[p] = max;
          p--;
        }

        // nums2剩余部分
        if(p2 >= 0){
          System.arraycopy(nums2, 0, nums1, 0, p2+1);
        }

      }
  	}
	
# Review
## Linux debugging tools I love <https://jvns.ca/blog/2016/07/03/debugging-tools-i-love/>  
#### 该文列举了作者最喜欢的几个Linux下调试的工具
 - strace，跟踪系统调用；
 - dstat，每秒打印来自网络写入磁盘的数据量；
 - tcpdump+wiredshark，打印网络包；
 - perf，打印C程序的占用CPU时间；
 - opensnoop，展示当前计算机上有哪些打开的文件；


# Tips
#### 字节码执行引擎
 - 栈帧结构：局部变量表、操作数栈、动态连接、方法返回地址、附加信息；
 - 方法调用-解析：在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，前提是方法在程序真正运行之前就有一个可确定的调用版本。有静态方法、私有方法、实例构造器、父类方法4类，及虚方法中使用final修饰的。解析调用在编译阶段就完全确定。
 - 方法调用-分派：到Java 1.8，Java语言是一门静态多分派、动态单分派的语言。
 - 静态分派（方法重载）：依赖静态类型定位方法执行版本。编译期间选择静态分派目标，实现了方法重载。关注接受者和参数等多个宗量，因此静态分派是多分派。
 - 动态分派（重写）：invokevirtual指令执行的第一步就是在运行期确定接收者的实际类型，然后在自己类中找方法，再从下往上依次对C的各个父类。这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。只关注接收者的实际类型一个宗量，因此动态分派是单分派。
 - 动态分派实现：不搜索元数据中的所有方法，而在方法区中加入虚方法表。如果某个方法在子类中没有被重写，那子类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类中重写了这个方法，子类方法表中的地址将会替换为指向子类实现版本的入口地址。


# Share
### 哈希算法
#### 设计一个哈希算法的要求
 - 从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）；
 - 对输入数据非常敏感，哪怕原始数据只修改了一个 Bit，最后得到的哈希值也大不相同；
 - 散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小；
 - 哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值。
#### 哈希算法的应用
唯一标识、校验数据的完整性和正确性、安全加密、散列函数、负载均衡、数据分片、分布式存储。

